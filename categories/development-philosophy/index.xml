<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>development philosophy on BRYSGO</title><link>http://brysgo.com/categories/development-philosophy/</link><description>Recent content in development philosophy on BRYSGO</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 21 Jun 2016 01:54:33 +0000</lastBuildDate><atom:link href="http://brysgo.com/categories/development-philosophy/index.xml" rel="self" type="application/rss+xml"/><item><title>Crystallize your abstractions carefully...</title><link>http://brysgo.com/2016/06/21/crystallize-carfully/</link><pubDate>Tue, 21 Jun 2016 01:54:33 +0000</pubDate><guid>http://brysgo.com/2016/06/21/crystallize-carfully/</guid><description>For as long as I&amp;rsquo;ve been a developer I have been reminded of the rule of three for refactoring and every time I hear it, I die a little inside.
If building a new abstraction is so painful, that it is easier to copy and paste large chunks of code, you need to rethink the way you are building your abstractions. Building the right abstractions isn&amp;rsquo;t just a time consuming distraction from building software, it is software engineering.</description></item><item><title>Imaginary Lines</title><link>http://brysgo.com/2016/04/01/imaginary-lines/</link><pubDate>Fri, 01 Apr 2016 01:13:33 +0000</pubDate><guid>http://brysgo.com/2016/04/01/imaginary-lines/</guid><description>If I had to sum up the job of a software engineer in laymen&amp;rsquo;s terms, I would tell you that we draw imaginary lines around imaginary concepts until those concepts can map to both a specific set of instructions for a machine and a common understanding for programmers.
Why am I stating the obvious? Well, it is quite simply to emphasize just how important it is where we draw those lines.</description></item><item><title>The wonderful distributed world wide web!</title><link>http://brysgo.com/2014/12/01/the-wonderful-distributed-world-wide-web/</link><pubDate>Mon, 01 Dec 2014 23:05:17 +0000</pubDate><guid>http://brysgo.com/2014/12/01/the-wonderful-distributed-world-wide-web/</guid><description>…umm, I mean let’s all use the same service so we don’t have to manage or own hardware.
There are advantages and disadvantages to distributing the internet. One of the advantages initially were that it was the only way to host anything. There were no easy services for sharing content.
There are of course many other advantages to the distribution of the internet, like fault tolerance, but those were quickly forgotten.</description></item><item><title>Commit to a single way</title><link>http://brysgo.com/2014/11/26/commit-to-a-single-way/</link><pubDate>Wed, 26 Nov 2014 13:13:06 +0000</pubDate><guid>http://brysgo.com/2014/11/26/commit-to-a-single-way/</guid><description>Software engineers are responsible for adding new and unforeseen complexity to established, carefully thought out systems.
It tends to be a reflex when told to add complexity, that we special case the complexity and fall through to the system you had before. This works in many cases and is great if the complexity being added is a footnote that you don&amp;rsquo;t intend to come back to.
Complexity that is essential to the long term success of your product needs to be &amp;ldquo;native.</description></item><item><title>Why is consistency in code so difficult?</title><link>http://brysgo.com/2014/11/19/why-is-consistency-in-code-so-difficult/</link><pubDate>Wed, 19 Nov 2014 22:39:00 +0000</pubDate><guid>http://brysgo.com/2014/11/19/why-is-consistency-in-code-so-difficult/</guid><description>
&lt;p>Why is it we can’t just agree on a pattern to use when programming and get everything done already?&lt;/p>
&lt;p>The fact is that while language level stylistic differences are very easy to agree on, the patterns in which you use the tools provided by the language emerge proportional to the size of the system.&lt;/p>
&lt;p>So you can come to a new pattern, agree on it, come to the next, agree on it, etc… but there will always be more patterns.&lt;/p>
&lt;p>Okay well, we can’t agree on patterns, at least we can agree on philosophies for coming up with new patterns?</description></item><item><title>A RoseFactory by any other name...</title><link>http://brysgo.com/2014/11/18/a-rosefactory-by-any-other-name/</link><pubDate>Tue, 18 Nov 2014 22:54:00 +0000</pubDate><guid>http://brysgo.com/2014/11/18/a-rosefactory-by-any-other-name/</guid><description>
&lt;blockquote>
&lt;p>There are only two hard things in Computer Science: cache invalidation and naming things.&lt;/p>
&lt;p>— Phil Karlton&lt;/p>
&lt;/blockquote>
&lt;p>Lets hold on to cache invalidation for another post&lt;a href="https://www.youtube.com/watch?v=g-4-gLlF0uw">…&lt;/a>&lt;/p>
&lt;p>Naming things (or should I say labeling them&lt;a href="https://www.youtube.com/watch?v=g-4-gLlF0uw">…&lt;/a>) is a very hard problem.&lt;/p>
&lt;h2>Why is it a hard problem?&lt;/h2>
&lt;p>Consider this, imagine you are building a piece of IKEA furniture. You get all the pieces in the box and you have to put them together. Now imagine that all the pieces had a succinct description that you used to put them together. Now imagine that you couldn’t see or feel the pieces and all you had to work with were these descriptions.&lt;/p>
&lt;p>&lt;img alt="" src="http://photos1.blogger.com/blogger2/1715/1669/1600/larson-oct-1987.gif"/>&lt;/p>
&lt;p></description></item><item><title>OO code isn't spaghetti proof</title><link>http://brysgo.com/2014/11/15/oo-code-isnt-spaghetti-proof/</link><pubDate>Sat, 15 Nov 2014 02:11:50 +0000</pubDate><guid>http://brysgo.com/2014/11/15/oo-code-isnt-spaghetti-proof/</guid><description>Today I had another terrifying, tear swallowing pull request moment. It involved clearly abstracted pieces of our system being clearly and purposefully coupled. If this doesn&amp;rsquo;t bring you to your knees let me try and illustrate why this is so bad.
You are the kind of developer that pardon my french, &amp;ldquo;gets shit done.&amp;rdquo; Because you are such a doer, you connect the first input with the desired output. You repeat this with a different input and output a few times.</description></item></channel></rss>